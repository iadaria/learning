# Типы данных

## Методы примитивов

JavaScript позволяет нам работать с примитивными типами данных – строками, числами и т.д., как будто они являются объектами. У них есть и методы

Отличие от примитивов:
- Это – значение «примитивного» типа. Одно значение.
- Есть 7 примитивных типов: string, number, boolean, symbol, null, undefined и bigint.

Объект
- Может хранить множество значений как свойства.
- Объявляется при помощи фигурных скобок {}, например: {name: "Рома", age: 30}. В JavaScript есть и другие виды объектов: например, функции тоже являются объектами.
- Одна из лучших особенностей объектов – это то, что мы можем хранить функцию как одно из свойств объекта.
  
Объекты «тяжелее» примитивов. Они нуждаются в дополнительных ресурсах для поддержания внутренней структуры.\
Каждый примитив имеет свой собственный «объект-обёртку», которые называются: String, Number, Boolean, Symbol и BigInt.\
К примеру, существует метод `str.toUpperCase()`, который возвращает строку в верхнем регистре.\
1) В момент обращения к его свойству, создаётся специальный объект, который знает значение строки и имеет такие полезные методы.
2) Этот метод запускается и возвращает новую строку
3) Специальный объект удаляется, оставляя только примитив str.\
Получается, что примитивы могут предоставлять методы, и в то же время оставаться «лёгкими».
```js
'Hello'.toUpperCase(); // HELLO
```
`new` в JavaScript, это тоже возможно по историческим причинам, но очень не рекомендуется.\
С другой стороны, использование функций String/Number/Boolean без оператора new – вполне разумно и полезно. Они превращают значение в соответствующий примитивный тип: в строку, в число, в булевый тип.
```js
alert( typeof 0 ); // "число"
alert( typeof new Number(0) ); // "object"!

let num = Number("123"); // превращает строку в число
```
!null/undefined не имеют методов.\
У них нет соответствующих «объектов-обёрток», и они не имеют никаких методов. В некотором смысле, они «самые примитивные».

# Числа
В современном JavaScript существует два типа чисел:
- Обычные числа в JavaScript хранятся в 64-битном формате IEEE-754, который также называют «числа с плавающей точкой двойной точности» 
- BigInt числа дают возможность работать с целыми числами произвольной длины. Они нужны достаточно редко и используются в случаях, когда необходимо работать со значениями более чем (253-1) или менее чем -(253-1).
```js
// Один из способов записи
let billion = 1_000 // 1000
let billion = 1e9;  // 1 миллиард, буквально: 1 и 9 нулей
let mcs = 0.000001;
let mcsE = 1e-6; // шесть нулей слева
alert( 0xff ); // 255

1e-3 === 1 / 1000; // (=0.001)
let a = 0b11111111; // двоичная (бинарная) форма записи числа 255
let b = 0o377; // восьмеричная форма записи числа 255.
```
- Символ нижнего подчёркивания _ – это «синтаксический сахар»
- "e" умножает число на 1 с указанным количеством нулей.
- Естественно, есть короткий стиль записи: 0x, используется в представлении цветов.

Функции:
- `toString(base)` Метод `num.toString(base)` возвращает строковое представление числа num в системе счисления base.
- Если нам надо вызвать метод непосредственно на числе, то нам надо поставить две точки .. после числа(после первой точки начинается десятичная часть, а две точки значит что она отсутствует).
- Округление: `Math.floor`, `Math.ceil`, `Math.round`, `Math.trunc`.
- `num.toFixed(n)` оклугляет до `n` знаков после запятой и возвращает строковое значение.
- обходим проблему неточности в js с помощью округления `sum.toFixed(2)`
- Другим забавным следствием внутреннего представления чисел является наличие двух нулей: `0` и `-0`. Все потому, что знак представлен отдельным битом, так что, любое число может быть положительным и отрицательным, включая нуль.\
- ` isFinite и isNaN`
- `Infinity (и -Infinity)` — особенное численное значение, которое ведёт себя в точности как математическая бесконечность `∞`.
- `NaN `представляет ошибку.
- `isNaN(value)` преобразует значение в число и проверяет является ли оно NaN
[Нужна ли нам эта функция? Разве не можем ли мы просто сравнить === NaN? К сожалению, нет. Значение NaN уникально тем, что оно не является равным ничему другому, даже самому себе:]
- `isFinite(value)` преобразует аргумент в число и возвращает true, если оно является обычным числом, т.е. не NaN/Infinity/-Infinity:
- Методы `Number.isNaN и Number.isFinite` – это более «строгие» версии функций `isNaN и isFinite`. Они не преобразуют аргумент в число, а наоборот – первым делом проверяют, является ли аргумент числом (принадлежит ли он к типу number).
```js
let num = 255;

alert( num.toString(16) );  // ff
alert( num.toString(2) );   // 11111111

12356..toString(36) // в 36-разр сис.сч.

let num = 12.34;
alert( num.toFixed(1) ); // "12.3"

5..toFixed(5); //"5.00000" 

// Переполнили 64-битное хранилище
alert( 1e500 ); // Infinity 

alert( 0.1 + 0.2 ); // 0.30000000000000004

alert( NaN === NaN ); // false

alert( isFinite("15") ); // true
alert( isFinite("str") ); // false, потому что специальное значение: NaN
alert( isFinite(Infinity) ); // false, 
```
[Число хранится в памяти в бинарной форме, как последовательность бит – единиц и нулей. Но дроби, такие как 0.1, 0.2, которые выглядят довольно просто в десятичной системе счисления, на самом деле являются бесконечной дробью в двоичной форме.\
Другими словами, что такое 0.1? Это единица делённая на десять — 1/10, одна десятая. В десятичной системе счисления такие числа легко представимы, по сравнению с одной третьей: 1/3, которая становится бесконечной дробью 0.33333(3).\
Деление на 10 гарантированно хорошо работает в десятичной системе, но деление на 3 – нет\
1/10 становится бесконечной дробью.ё
Причина та же – потеря точности. Из 64 бит, отведённых на число, сами цифры числа занимают до 52 бит, остальные 11 бит хранят позицию десятичной точки и один бит – знак. ]

```js
alert(0.1.toString(2)); // 0.0001100110011001100110011001100110011001100110011001101
alert(0.2.toString(2)); // 0.001100110011001100110011001100110011001100110011001101
alert((0.1 + 0.2).toString(2)); // 0.0100110011001100110011001100110011001100110011001101

alert( +0.1.toFixed(20) ); // 0.10000000000000000555

alert( 9999999999999999 ); // покажет 10000000000000000
```
Существует специальный метод `Object.is`, который сравнивает значения примерно как ===, но более надёжен в двух особых ситуациях:
- Работает с NaN: Object.is(NaN, NaN) === true, здесь он хорош.
- Значения 0 и -0 разные: Object.is(0, -0) === false, это редко используется, но технически эти значения разные.
  
Во всех других случаях Object.is(a, b) идентичен a === b.

```js
```

```js
```


```js
```