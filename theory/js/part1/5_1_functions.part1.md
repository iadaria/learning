# Рекурсия и стек

Рекурсия в JavaScript — это процесс вызова функцией самой себя. Функция, которая в своём теле вызывает сама себя, называется рекурсивной функцией.\
Внутри рекурсивной функции обязательно должно находиться условие выхода из рекурсии. Иначе функция будет вызывать саму себя бесконечно. Как только условие выхода выполняется, функция перестаёт вызывать себя.\
Чтобы предотвратить бесконечную рекурсию, можно использовать оператор if...else, в котором одна ветвь выполняет рекурсивный вызов, а другая — нет.\
Итеративный способ
```js
function pow(x, n) {
  let result = 1;

  // умножаем result на x n раз в цикле
  for (let i = 0; i < n; i++) {
    result *= x;
  }

  return result;
}

alert( pow(2, 3) ); // 8
```
Рекурсивный способ: упрощение задачи и вызов функцией самой себя:
```js
function pow(x, n) {
  if (n == 1) {
    return x;
  } else {
    return x * pow(x, n - 1);
  }
}

alert( pow(2, 3) ); // 8
```
Когда функция pow(x, n) вызывается, исполнение делится на две ветви:
Рекурсивное решение задачи обычно короче, чем итеративное.
```js
function pow(x, n) {
  return (n == 1) ? x : (x * pow(x, n - 1));
}
```
Общее количество вложенных вызовов (включая первый) называют глубиной рекурсии. В нашем случае она будет равна n.\
Максимальная глубина рекурсии ограничена движком JavaScript. Точно можно рассчитывать на 10000 вложенных вызовов, некоторые интерпретаторы допускают и больше, но для большинства из них 100000 вызовов – за пределами возможностей.\
Информация о процессе выполнения запущенной функции хранится в её контексте выполнения (execution context).

Контекст выполнения – специальная внутренняя структура данных, которая содержит информацию о вызове функции. Она включает в себя конкретное место в коде, на котором находится интерпретатор, локальные переменные функции, значение this и прочую служебную информацию.ё
Один вызов функции имеет ровно один контекст выполнения, связанный с ним.

Когда функция производит вложенный вызов, происходит следующее:
1) Выполнение текущей функции приостанавливается.
2) Контекст выполнения, связанный с ней, запоминается в специальной структуре данных – *стеке контекстов выполнения*.
3) Выполняются вложенные вызовы, для каждого из которых создаётся свой контекст выполнения.
4) После их завершения старый контекст достаётся из стека, и выполнение внешней функции возобновляется с того места, где она была остановлен.
5) Когда функция заканчивается(может возвращать результ), контекст её выполнения больше не нужен, поэтому он удаляется из памяти, а из стека восстанавливается предыдущий\
Как видно из иллюстраций выше, глубина рекурсии равна максимальному числу контекстов, одновременно хранимых в стеке.\
Обратим внимание на требования к памяти. Рекурсия приводит к хранению всех данных для неоконченных внешних вызовов в стеке, и в данном случае это приводит к тому, что возведение в степень n хранит в памяти n различных контекстов.\
Реализация возведения в степень через цикл гораздо более экономна.\
Любая рекурсия может быть переделана в цикл. Как правило, вариант с циклом будет эффективнее.\
Часто код с использованием рекурсии более короткий, лёгкий для понимания и поддержки. 

(*) Списки ... Реши хотя бы задачу

# Область видимости переменных, замыкание

JavaScript – язык с сильным функционально-ориентированным уклоном.\
Функция может быть динамически создана, скопирована в другую переменную или передана как аргумент другой функции и позже вызвана из совершенно другого места.\
Мы знаем, что функция может получить доступ к переменным из внешнего окружения

## Блоки кода
Если переменная объявлена внутри блока кода {...}, то она видна только внутри этого блока.\
Для if, for, while и т.д. переменные, объявленные в блоке кода {...}, также видны только внутри.\
Визуально let i = 0; находится вне блока кода {...}, однако здесь в случае с for есть особенность: переменная, объявленная внутри (...), считается частью блока.
```js
{
  let message = "Hello"; // переменная видна только в этом блоке
  alert(message); // Hello
}
{
  // показать другое сообщение
  let message = "Goodbye";
  alert(message);
}
alert(message); // ReferenceError: message is not defined

for (let i = 0; i < 3; i++) {
  // переменная i видна только внутри for
  alert(i); // 0, потом 1, потом 2
}
```
## Вложенные функции
Функция называется «вложенной», когда она создаётся внутри другой функции.
```js
function sayHiBye(firstName, lastName) {
  // функция-помощник, которую мы используем ниже
  function getFullName() {
    return firstName + " " + lastName;
  }
  alert( "Hello, " + getFullName() );
  alert( "Bye, " + getFullName() );
}
```
Что ещё интереснее, вложенная функция может быть возвращена: либо в качестве свойства нового объекта (если внешняя функция создаёт объект с методами), либо сама по себе. И затем может быть использована в любом месте. Не важно где, она всё так же будет иметь доступ к тем же внешним переменным.
```js
function makeCounter() {
  let count = 0;

  return function() {
    return count++; // есть доступ к внешней переменной "count"
  };
}

let counter = makeCounter();

alert( counter() ); // 0
alert( counter() ); // 1
alert( counter() ); // 2
```

# Лексическое окружение

В JavaScript у каждой выполняемой функции, блока кода {...} и скрипта есть связанный с ними внутренний (скрытый) объект, называемый лексическим окружением LexicalEnvironment.\
Объект лексического окружения состоит из двух частей:
1) Environment Record – объект, в котором как свойства хранятся все локальные переменные (а также некоторая другая информация, такая как значение this).
2) Ссылка на внешнее лексическое окружение – то есть то, которое соответствует коду снаружи (снаружи от текущих фигурных скобок).

"Переменная" – это просто свойство специального внутреннего объекта: Environment Record. «Получить или изменить переменную», означает, «получить или изменить свойство этого объекта».\
Глобальное лексическое окружение, связанное со всем скриптом. У глобального лексического окружения нет внешнего окружения, так что она указывает на null.\
«Лексическое окружение» – это объект спецификации: он существует только «теоретически» в спецификации языка для описания того, как все работает. Мы не можем получить этот объект в нашем коде и манипулировать им напрямую.

Функция – это тоже значение, как и переменная.\
Разница заключается в том, что Function Declaration мгновенно инициализируется полностью.\
Когда создается лексическое окружение, Function Declaration сразу же становится функцией, готовой к использованию (в отличие от let, который до момента объявления не может быть использован).\
Именно поэтому мы можем вызвать функцию, объявленную как Function Declaration, до самого её объявления.

## 3.Внутреннее и внешнее лексическое окружение

Когда код хочет получить доступ к переменной – сначала происходит поиск во внутреннем лексическом окружении, затем во внешнем, затем в следующем и так далее, до глобального.

Если переменная не была найдена, это будет ошибкой в строгом режиме (use strict). Без строгого режима, для обратной совместимости, присваивание несуществующей переменной создаёт новую глобальную переменную с таким же именем.

## 4.Возврат функции

Все функции помнят лексическое окружение, в котором они были созданы. Технически здесь нет никакой магии: все функции имеют скрытое свойство [[Environment]], которое хранит ссылку на лексическое окружение, в котором была создана функция.
Ссылка на [[Environment]] устанавливается один раз и навсегда при создании функции.\
! Переменная обновляется в том лексическом окружении, в котором она существует.

! Замыкание – это функция, которая запоминает свои внешние переменные и может получить к ним доступ. В некоторых языках это невозможно, или функция должна быть написана специальным образом, чтобы получилось замыкание. Но, как было описано выше, в JavaScript, все функции изначально являются замыканиями (есть только одно исключение, про которое будет рассказано в Синтаксис "new Function").

То есть они автоматически запоминают, где были созданы, с помощью скрытого свойства [[Environment]], и все они могут получить доступ к внешним переменным.

Все функции в JavaScript являются замыканиями, и, может быть, несколько слов о технических деталях: свойстве [[Environment]] и о том, как работает лексическое окружение.

## Сборка мусора
```js
```

```js
```