# Структура кода

Инструкции – это синтаксические конструкции и команды, которые выполняют действия. Мы уже видели инструкцию alert('Привет, мир!').
Инструкции могут отделяться точкой с запятой.
В большинстве случаев точку с запятой можно не ставить, если есть переход на новую строку.
В этом случае JavaScript интерпретирует перенос строки как «неявную» точку с запятой. Это называется автоматическая вставка точки с запятой.
```javascript
alert('Привет')
alert('Мир')
```
Но «в большинстве случаев» не значит «всегда»!
Но есть ситуации, где JavaScript «забывает» вставить точку с запятой там, где она нужна.
Ошибки, которые при этом появляются, достаточно сложно обнаруживать и исправлять.
```js
alert('Hello')

[1, 2].forEach(alert);
```
Это потому что JavaScript не вставляет точку с запятой перед квадратными скобками [...]. Получим:
```js
alert('Hello')[1, 2].forEach(alert);
// видимо ожидаем здесь возврат чего-то после выполнение функции и обращаемся к элементу массива, поэтому видим 'Hello' и error: TypeError: Cannot read properties of undefined (reading '2')
```
# Строгий режим 'use strict'

Новые функции добавлялись в язык, в то время как старая функциональность не менялась. Так было до 2009 года, когда появился ECMAScript 5 (ES5). Он добавил новые возможности в язык и изменил некоторые из существующих. Чтобы устаревший код работал, как и раньше, по умолчанию подобные изменения не применяются. Поэтому нам нужно явно их активировать с помощью специальной директивы: "use strict".
Когда она находится в начале скрипта, весь сценарий работает в «современном» режиме.
```js
"use strict";
// этот код работает в современном режиме
...
```
В начале большинства видов функций можно поставить "use strict". Это позволяет включить строгий режим только в конкретной функции. Но обычно люди используют его для всего файла.
Как только мы входим в строгий режим, отменить это невозможно.
```js
alert("some code");
// "use strict" ниже игнорируется - он должен быть в первой строке
"use strict";
// строгий режим не активирован
```
Над "use strict" могут быть записаны только комментарии.
Включаем его в консоли браузера:
```js
(function() {
  'use strict';
  // ...ваш код...
})()
```
Современный JavaScript поддерживает «классы» и «модули» — продвинутые структуры языка, которые автоматически включают строгий режим. Поэтому в них нет нужды добавлять директиву "use strict".
Подытожим: пока очень желательно добавлять "use strict"; в начале ваших скриптов. Позже, когда весь ваш код будет состоять из классов и модулей, директиву можно будет опускать.

# Переменные

Переменные используются для хранения информации.
Переменная – это «именованное хранилище» для данных. 
Для создания переменной в JavaScript используйте ключевое слово let.
Приведённая ниже инструкция создаёт (другими словами, объявляет) переменную с именем «message»:
```js
let message;
```
Теперь можно поместить в неё данные (другими словами, определить переменную), используя оператор присваивания =:
```js
let message;
message = 'Hello';
```
Строка сохраняется в области памяти, связанной с переменной. Мы можем получить к ней доступ, используя имя переменной:

```js
let user = 'John', age = 25, message = 'Hello';
```
Повторное объявление той же переменной является ошибкой.
В JavaScript есть два ограничения, касающиеся имён переменных:
- Имя переменной должно содержать только буквы, цифры или символы $ и _.
- Первый символ не должен быть цифрой.
Если имя содержит несколько слов, обычно используется верблюжья нотация, то есть, слова следуют одно за другим, где каждое следующее слово начинается с заглавной буквы: myVeryLongName.
```js
let $ = 1; // объявили переменную с именем "$"
let _ = 2; // а теперь переменную с именем "_"

alert($ + _); // 3
```
!Регистр имеет значение
Переменные с именами apple и APPLE – это две разные переменные.

Нелатинские буквы разрешены, но не рекомендуются
```js
let имя = '...';
let 我 = '...';
```
Существует список зарезервированных слов, которые нельзя использовать в качестве имён переменных, потому что они используются самим языком.
Например: let, class, return и function зарезервированы.
```js
let let = 5; // нельзя назвать переменную "let", ошибка!
let return = 5; // также нельзя назвать переменную "return", ошибка!
```

```js
"use strict";
num = 5; // ошибка: num is not defined
```
Чтобы объявить константную, то есть, неизменяемую переменную, используйте const вместо let.
Широко распространена практика использования констант в качестве псевдонимов для трудно запоминаемых значений, которые известны до начала исполнения скрипта.
Названия таких констант пишутся с использованием заглавных букв и подчёркивания.
Константы известные еще до выполнения.
```js
const COLOR_RED = "#F00";
const COLOR_GREEN = "#0F0";
const COLOR_BLUE = "#00F";
const COLOR_ORANGE = "#FF7F00";

// ...когда нам нужно выбрать цвет
let color = COLOR_ORANGE;
alert(color); // #FF7F00
```

# Типы данных

Примитивные - так как содержать одно значение(строка число или другое)

В JavaScript есть 8 основных типов данных.
Семь из них называют «примитивными» типами данных:
1 number для любых чисел: целочисленных или чисел с плавающей точкой; целочисленные значения ограничены диапазоном ±(2^53-1).
2 bigint для целых чисел произвольной длины.
3 string для строк. Строка может содержать ноль или больше символов, нет отдельного символьного типа.
4 boolean для true/false.
5 null для неизвестных значений – отдельный тип, имеющий одно значение null.
6 undefined для неприсвоенных значений – отдельный тип, имеющий одно значение undefined.
7 symbol для уникальных идентификаторов.
И один не является «примитивным» и стоит особняком:
8 object для более сложных структур данных.

Оператор typeof позволяет нам увидеть, какой тип данных сохранён в переменной.
Имеет две формы: typeof x или typeof(x).
Возвращает строку с именем типа. Например, "string".
Для null возвращается "object" – это ошибка в языке, на самом деле это не объект.

Кроме обычных чисел, существуют так называемые «специальные числовые значения», которые относятся к этому типу данных числовому: Infinity, -Infinity и NaN.
Infinity представляет собой математическую бесконечность ∞. Это особое значение, которое больше любого числа.

Мы можем получить его в результате деления на ноль:
```js
alert( 1 / 0 ); // Infinity
alert( Infinity ); // Infinity задаем явно
```
NaN означает вычислительную ошибку. Это результат неправильной или неопределённой математической операции, например:
```js
alert( "не число" / 2 ); // NaN, такое деление является ошибкой
```
Значение NaN «прилипчиво». Любая математическая операция с NaN возвращает NaN:
```js
alert( NaN + 1 ); // NaN
alert( 3 * NaN ); // NaN
alert( "не число" / 2 - 1 ); // NaN
```
Если где-то в математическом выражении есть NaN, то оно распространяется на весь результат (есть только одно исключение: NaN ** 0 равно 1)
Математические операции – безопасны
Скрипт никогда не остановится с фатальной ошибкой (не «умрёт»). В худшем случае мы получим NaN как результат выполнения.
Чтобы создать значение типа BigInt, необходимо добавить n в конец числового литерала:
```js
// символ "n" в конце означает, что это BigInt
const bigInt = 1234567890123456789012345678901234567890n;
```
*В JavaScript существует три типа кавычек.
- Двойные кавычки: "Привет".
- Одинарные кавычки: 'Привет'.
- Обратные кавычки: `Привет`.
Обратные же кавычки имеют расширенную функциональность. Они позволяют нам встраивать выражения в строку, заключая их в ${…}. Например:
```js
let name = "Иван";
// Вставим переменную
alert( `Привет, ${name}!` ); // Привет, Иван!
```
!Нет отдельного типа данных для одного символа.

*В JavaScript null не является «ссылкой на несуществующий объект» или «нулевым указателем», как в некоторых других языках.
Это просто специальное значение, которое представляет собой «ничего», «пусто» или «значение неизвестно»:
```js
let age = null;
```
*Специальное значение undefined также стоит особняком. Оно формирует тип из самого себя так же, как и null. Оно означает, что «значение не было присвоено»:
```js
let age;
alert(age); // выведет "undefined"
```
…Но так делать не рекомендуется. Обычно null используется для присвоения переменной «пустого» или «неизвестного» значения, а undefined – для проверок, была ли переменная назначена.

*Тип object (объект) – особенный.
В объектах же хранят коллекции данных или более сложные структуры.

*Тип symbol (символ) используется для создания уникальных идентификаторов в объектах.
```js
typeof undefined // "undefined"

typeof 0.23 // "number"

typeof 10n // "bigint"

typeof true // "boolean"

typeof "foo" // "string"

typeof Symbol("id") // "symbol"

typeof Math // "object"  (1)

typeof null // "object"  (2)

typeof alert // "function"  (3)

typeof Infinity // "number"
```

# alert, prompt, confirm

*Она показывает сообщение и ждёт, пока пользователь нажмёт кнопку «ОК».

*Модальное означает, что пользователь не может взаимодействовать с интерфейсом остальной части страницы, нажимать на другие кнопки и т.д. до тех пор, пока взаимодействует с окном. 
```js
let result = prompt(title, [default]);
```
Введённый текст будет присвоен переменной result
```js
result = confirm(question);
```
Возвращает true/false
```js
```
Все эти методы являются модальными.

# Преобразование типов

Чаще всего операторы и функции автоматически приводят переданные им примитивные значения к нужному типу(alert, +)
1 String: Преобразование происходит очевидным образом. false становится "false", null становится "null" и т.п.
2 Number:
- undefined ->	NaN
- null ->	0
- true / false -> 	1 / 0
- string: 	Пробельные символы (пробелы, знаки табуляции \t, знаки новой строки \n и т. п.) по краям обрезаются. Далее, если остаётся пустая строка, то получаем 0, иначе из непустой строки «считывается» число. При ошибке результат NaN.
Учтите, что null и undefined ведут себя по-разному. Так, null становится нулём, тогда как undefined приводится к NaN
3 Boolean:
- Значения, которые интуитивно «пустые», вроде 0, пустой строки "", null, undefined и NaN, становятся false.
- Все остальные значения становятся true.
- Эту запись можно укоротить при помощи совмещённых операторов += и *=. Подобные краткие формы записи существуют для всех арифметических и побитовых операторов: /=, -=, **= и так далее.
- Инкремент ++ увеличивает переменную на 1
- Декремент -- уменьшает переменную на 1
- Инкремент/декремент можно применить только к переменной. Попытка использовать его на значении, типа 5++, приведёт к ошибке
- Когда оператор идёт после переменной — это «постфиксная форма»: counter++.
- «Префиксная форма» — это когда оператор идёт перед переменной: ++counter.


```js
let value = true;
alert(typeof value); // boolean

value = String(value); // теперь value это строка "true"
alert(typeof value); // string

alert( "6" / "2" ); // 3, строки преобразуются в числа

let age = Number("Любая строка вместо числа"); // Nan

alert( Boolean(1) ); // true
alert( Boolean(0) ); // false

alert( Boolean("Привет!") ); // true
alert( Boolean("") ); // false

alert( Boolean("0") ); // true
alert( Boolean(" ") ); // пробел это тоже true (любая непустая строка это true)
```
# Базовые операторы

- Операнд – то, к чему применяется оператор. Например, в умножении 5 * 2 есть два операнда: левый операнд равен 5, а правый операнд равен 2. Иногда их называют «аргументами» вместо «операндов».
- Унарным называется оператор, который применяется к одному операнду. Например, оператор унарный минус "-" меняет знак числа на противоположный:
- Бинарным называется оператор, который применяется к двум операндам. 
- или оператор отрицания (унарный оператор, который обращает знак) и оператор вычитания (бинарный оператор, который вычитает одно число из другого).
- Взятие остатка от деления %
- Возведение в степень **
- В том случае, если в выражении есть несколько операторов – порядок их выполнения определяется приоритетом, или, другими словами, существует определённый порядок выполнения операторов.
- В JavaScript много операторов. Каждый оператор имеет соответствующий номер приоритета. Тот, у кого это число больше, – выполнится раньше. Если приоритет одинаковый, то порядок выполнения – слева направо. Такое присваивание работает справа налево.
- присваивание по цепочке
*Сложение строк:
- Обратите внимание, если хотя бы один операнд является строкой, то второй будет также преобразован в строку.
- Сложение и преобразование строк — это особенность бинарного плюса +
- Если операнд не число, унарный плюс преобразует его в число.
- Оператор «запятая» (,) редко применяется и является одним из самых необычных.
Оператор «запятая» предоставляет нам возможность вычислять несколько выражений, разделяя их запятой ,. Каждое выражение выполняется, но возвращается результат только последнего. Оператор имеет очень низкий приоритет, ниже =, поэтому скобки важны в приведённом примере. Иногда его используют в составе более сложных конструкций, чтобы сделать несколько действий в одной строке.

Приоритеты:
15	унарный плюс	+
15	унарный минус	-
14	возведение в степень	**
13	умножение	*
13	деление	/
12	сложение	+
12	вычитание	-
2	присваивание	=

```js
let x = 1;

x = -x;  // -1, применили унарный минус

let x = 1, y = 3;
alert( y - x ); // 2, бинарный минус вычитает значения

alert( 5 % 2 ); // 1, остаток от деления 5 на 2
alert( 8 % 4 ); // 0, остаток от деления 8 на 4

alert( 2 ** 2 ); // 2² = 4

let s = "моя" + "строка"; // моястрока

alert( '1' + 2 ); // "12"
alert( 2 + '1' ); // "21"

alert(2 + 2 + '1' ); // будет "41", а не "221"

alert( 6 - '2' ); // 4, '2' приводится к числу
alert( '6' / '2' ); // 3, оба операнда приводятся к числам

// Преобразует не числа в числа
alert( +true ); // 1
alert( +"" );   // 0

let apples = "2";
let oranges = "3";
alert( apples + oranges ); // "23"
// оба операнда предварительно преобразованы в числа
alert( +apples + +oranges ); // 5

let a = 1;
let b = 2;
let c = 3 - (a = b + 1);
alert( a ); // 3
alert( c ); // 0

a = b = c = 2 + 2; // цепочка присваиваний

let counter = 1;
let a = ++counter; // 2
let a = counter++; // 1

let a = (1 + 2, 3 + 4); // 7
a = 1 + 2, 3 + 4; //3

// три операции в одной строке
for (a = 1, b = 3, c = a * b; a < 10; a++) {
 ...
}
```

# Операторы сравнения

- Операторы сравнения возвращают значения логического типа.
- Строки сравниваются посимвольно в лексикографическом(алфавитном) порядке. Большей считается более длинная строка. Используется кодировка Unicode, а не настоящий алфавит. Заглавная буква "A" не равна строчной "a". Строчные буквы имеют больший код во внутренней таблице кодирования, которую использует JavaScript (Unicode).
- Значения разных типов при сравнении приводятся к числу. Операнды разных типов преобразуются оператором == к числу.  В итоге, и пустая строка, и false становятся нулём. Исключением является сравнение с помощью операторов строгого равенства/неравенства. Оператор строгого равенства === проверяет равенство без приведения типов. Другими словами, если a и b имеют разные типы, то проверка a === b немедленно возвращает false без попытки их преобразования. Ещё есть оператор строгого неравенства !==, аналогичный !=.
- Значения null и undefined равны == друг другу и не равны любому другому значению. При строгом равенстве === эти значения различны, так как различны их типы. !При нестрогом равенстве == эти значения равны друг другу и не равны никаким другим значениям.
- При использовании математических операторов и других операторов сравнения < > <= >= значения null/undefined преобразуются к числам: null становится 0, а undefined – NaN.
- undefined при сравнении преобразуется в NaN, а NaN – это специальное числовое значение, которое возвращает false при любых сравнениях
- Будьте осторожны при использовании операторов сравнений вроде > и < с переменными, которые могут принимать значения null/undefined. Хорошей идеей будет сделать отдельную проверку на null/undefined.

Как избежать проблем
- Зачем мы рассмотрели все эти примеры? Должны ли мы постоянно помнить обо всех этих особенностях? Необязательно. Со временем все они станут вам знакомы, но можно избежать проблем, если следовать надёжным правилам:
- Относитесь очень осторожно к любому сравнению с undefined/null, кроме случаев строгого равенства ===. Не используйте сравнения >= > < <= с переменными, которые могут принимать значения null/undefined, разве что вы полностью уверены в том, что делаете. Если переменная может принимать эти значения, то добавьте для них отдельные проверки.
```js
alert( 'Я' > 'А' ); // true
alert( 'Коты' > 'Кода' ); // true
alert( 'Сонный' > 'Сон' ); // true
console.log('коты' > 'Коты') // true

alert( '2' > 1 ); // true, строка '2' становится числом 2
alert( '01' == 1 ); // true, строка '01' становится числом 1

alert( true == 1 ); // true
alert( false == 0 ); // true

let a = 0;
alert( Boolean(a) ); // false
let b = "0";
alert( Boolean(b) ); // true
alert(a == b); // true!

alert( 0 == false ); // true
alert( '' == false ); // true
alert( 0 === false ); // false, так как сравниваются разные типы

alert( null == undefined ); // true
alert( null === undefined ); // false

alert( null > 0 );  // (1) false
alert( null == 0 ); // (2) false
alert( null >= 0 ); // (3) true

alert( undefined > 0 ); // false (1)
alert( undefined < 0 ); // false (2)
alert( undefined == 0 ); // false (3)
```

# Условное ветвление

Инструкция if (…) вычисляет выражение в скобках и преобразует результат к логическому типу:
- Число 0, пустая строка "", null, undefined и NaN становятся false. Из-за этого их называют «ложными» («falsy») значениями.
- Остальные значения становятся true, поэтому их называют «правдивыми» («truthy»).
-Так называемый «условный» оператор «вопросительный знак» позволяет нам сделать это более коротким и простым способом. Его также называют «тернарный», так как этот оператор, единственный в своём роде, имеет три аргумента. Смысл оператора «вопросительный знак» ? – вернуть то или иное значение, в зависимости от условия. Пожалуйста, используйте его именно для этого

```js
if (condition) {} else if {}

let result = условие ? значение1 : значение2;
```
Иногда оператор «вопросительный знак» ? используется в качестве замены if:
Не рекомендуется использовать оператор вопросительного знака таким образом.
```js
(company == 'Netscape') ?
 alert('Верно!') : alert('Неправильно.');
```

# Логические операторы

Логическое значение — это примитивный тип данных, который хранит одно из двух значений: true или false.
Конвертирование - преобразование(либо обмен) чего-либо в иную форму или в другую координатную систему.

В JavaScript есть семь логических операторов:
1) || (ИЛИ)
2) ||= (Оператор логического присваивания ИЛИ)
3) && (И)
4) &&= (Оператор логического присваивания И)
5) ! (НЕ)
6) ?? (Оператор нулевого слияния)
7) ??= (Оператор нулевого присваивания)

Несмотря на своё название, данные операторы могут применяться к значениям любых типов. Полученные результаты также могут иметь различный тип.

*|| (ИЛИ)
Традиционно в программировании ИЛИ предназначено только для манипулирования булевыми значениями.
При выполнении ИЛИ || с несколькими значениями:
- Вычисляет операнды слева направо.
- Каждый операнд конвертирует в логическое значение. Если результат true, останавливается и возвращает исходное значение этого операнда.
- Если все операнды являются ложными (false), возвращает последний из них.
- Значение возвращается в исходном виде, без преобразования.
Другими словами, цепочка ИЛИ || возвращает первое истинное значение или последнее, если такое значение не найдено.
```js
alert( true || true );   // true
alert( false || true );  // true
alert( true || false );  // true
alert( false || false ); // false

alert( 1 || 0 ); // 1 (1 - истинное значение)
alert( true || 'какая-то строка' ); // true

alert( null || 1 ); // 1 (первое истинное значение)
alert( null || 0 || 1 ); // 1 (первое истинное значение)
alert( undefined || null || 0 ); // 0 (поскольку все ложно, возвращается последнее значение)

let firstName = "";
let lastName = "";
let nickName = "Суперкодер";

alert( firstName || lastName || nickName || "Аноним"); // Суперкодер
```
!Обеспечивает так называемое "сокращенное вычисление"!.
Важность этой особенности становится очевидной, если операнд – это не просто значение, а выражение с сопутствующим эффектом, как, например, присваивание переменной или вызов функции.
```js
true || alert("никогда не сработает"); // нет сообщения
false || alert("сработает"); // "сработает"
```

*Оператор логического присваивания ИЛИ ||= принимает два операнда и выполняет следующие действия:
- Вычисляет операнды слева направо.
- Конвертирует a в логическое значение.
- Если a ложно, присваивает a значение b.
Концепция оператора ||= заключается в «сокращённом вычислении»!
Оператор логического присваивания ИЛИ ||= – это «синтаксический сахар», добавленный в язык в качестве более короткого варианта записи if-выражений с присваиванием.
```js
a ||= b; // a || (a = b);

let johnHasCar = false;

johnHasCar ||= "У Джона нет машины!"; // то же самое, что false || (johnHasCar = "...")
alert( johnHasCar ); // "У Джона нет машины!"
```
*И «&&» находит первое ложное значение.
Оператор && выполняет следующие действия:
- Вычисляет операнды слева направо.
- Каждый операнд преобразует в логическое значение. Если результат false, останавливается и возвращает исходное значение этого операнда.
- Если все операнды были истинными, возвращается последний.
Другими словами, И возвращает первое ложное значение. Или последнее, если ничего не найдено.
Вышеуказанные правила схожи с поведением ИЛИ. Разница в том, что И возвращает первое ложное значение, а ИЛИ –  первое истинное.
```js
// Если первый операнд истинный,
// И возвращает второй:
alert( 1 && 0 ); // 0
alert( 1 && 5 ); // 5

// Если первый операнд ложный,
// И возвращает его. Второй операнд игнорируется
alert( null && 5 ); // null
alert( 0 && "какая-то строка" ); // 0
alert( 1 && 2 && null && 3 ); // null
alert( 1 && 2 && 3 ); // 3
```
!Приоритет оператора И && больше, чем ИЛИ ||, так что он выполняется раньше.
Таким образом, код a && b || c && d по существу такой же, как если бы выражения && были в круглых скобках: (a && b) || (c && d).

[Несмотря на то, что вариант с && кажется более коротким, if более нагляден и, как правило, более читабелен. Поэтому мы рекомендуем использовать каждую конструкцию по назначению: использовать if, если нам нужно if, и использовать &&, если нам нужно И.]

*Оператор логического присваивания И &&= записывается как два амперсанда && и символ присваивания =.
```js
// &&= присвоит a значение b только в том случае, если a истинно.
a &&= b; //a && (a = b);

let greeting = "Привет"; // строка непустая, поэтому будет преобразована к логическому значению true оператором &&=
greeting &&= greeting + ", пользователь!"; // то же самое, что true && (greeting = greeting + "...")
alert( greeting ) // "Привет, пользователь!"
```
*Оператор ! (НЕ) принимает один аргумент и выполняет следующие действия:
- Сначала приводит аргумент к логическому типу true/false.
- Затем возвращает противоположное значение.
Приоритет НЕ ! является наивысшим из всех логических операторов, поэтому он всегда выполняется первым, перед && или ||.
```js
```

```js
```

```js
```

```js
```

```js
```