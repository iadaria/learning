# Объекты

Как мы знаем из главы Типы данных, в JavaScript существует 8 типов данных. Семь из них называются «примитивными», так как содержат только одно значение (будь то строка, число или что-то другое).
Объекты же используются для хранения коллекций различных значений и более сложных сущностей. 
Объекты – это ассоциативные массивы с рядом дополнительных возможностей.
В JavaScript есть много других типов объектов:
- Array для хранения упорядоченных коллекций данных,
- Date для хранения информации о дате и времени,
- Error для хранения информации об ошибке.

Объект может быть создан с помощью фигурных скобок {…} с необязательным списком свойств.Свойство – это пара «ключ: значение», где ключ – это строка (также называемая «именем свойства»), а значение может быть чем угодно.
```js
let user = new Object(); // синтаксис "конструктор объекта"
const user = {
  age: 1, //Это называется «висячая запятая». 
  "likes birds": true  // имя свойства из нескольких слов должно быть в кавычках
};  // синтаксис "литерал объекта"

user.isAdmin = true;
delete user.age;

// присваивание значения свойству
user["likes birds"] = true;

let key = "likes birds";
// то же самое, что и user["likes birds"] = true;
user[key] = true;

```
Обычно используют вариант с фигурными скобками {...}. Такое объявление называют литералом объекта или литеральной нотацией.
Значение может быть любого типа. Давайте добавим свойство с логическим значением.
Объект, объявленный через const, может быть изменён.
Мы можем использовать квадратные скобки в литеральной нотации для создания вычисляемого свойства.
Свойства могут быть ключи зарезервированные слова.
Если использовать число 0 в качестве ключа, то оно превратится в строку "0":
```js
// эти имена свойств допустимы
let obj = {
  for: 1,
  let: 2,
  return: 3
};

let obj = {
  0: "Тест" // то же самое что и "0": "Тест"
};
```
Есть небольшой подводный камень, связанный со специальным свойством __proto__. Мы не можем установить его в необъектное значение:
let obj = {};
obj.__proto__ = 5; // присвоим число
alert(obj.__proto__); // [object Object], значение - это объект, т.е. не то, что мы ожидали.

* При обращении к свойству, которого нет, возвращается undefined.
Также существует специальный оператор "in" для проверки существования свойства в объекте.
* Обратите внимание, что слева от оператора in должно быть имя свойства. Обычно это строка в кавычках.
Это когда свойство существует, но содержит значение undefined
```js
let user = {};
alert( user.noSuchProperty === undefined ); // true означает "свойства нет"

let obj = {
  test: undefined
};

alert( obj.test ); //  выведет undefined, значит свойство не существует?
alert( "test" in obj ); // true, свойство существует!
```
*Для перебора всех свойств объекта используется цикл for..in. Этот цикл отличается от изученного ранее цикла for(;;).
```js
let user = {
  name: "John",
  age: 30,
  isAdmin: true
};

for (let key in user) {
  // ключи
  alert( key );  // name, age, isAdmin
  // значения ключей
  alert( user[key] ); // John, 30, true
}
```
*Упорядоченность свойств. Свойства упорядочены особым образом: свойства с целочисленными ключами сортируются по возрастанию, остальные располагаются в порядке создания.
Термин «целочисленное свойство» означает строку, которая может быть преобразована в целое число и обратно без изменений.
```js
// Math.trunc - встроенная функция, которая удаляет десятичную часть
alert( String(Math.trunc(Number("49"))) ); // "49", то же самое ⇒ свойство целочисленное
alert( String(Math.trunc(Number("+49"))) ); // "49", не то же самое, что "+49" ⇒ свойство не целочисленное
alert( String(Math.trunc(Number("1.2"))) ); // "1", не то же самое, что "1.2" ⇒ свойство не целочисленное
```

```js
```

```js
```

```js
```

```js
```


```js
```

```js
```


```js
```

```js
```


```js
```

```js
```