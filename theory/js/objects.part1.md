# Объекты

Как мы знаем из главы Типы данных, в JavaScript существует 8 типов данных. Семь из них называются «примитивными», так как содержат только одно значение (будь то строка, число или что-то другое).
Объекты же используются для хранения коллекций различных значений и более сложных сущностей. 
Объекты – это ассоциативные массивы с рядом дополнительных возможностей.
В JavaScript есть много других типов объектов:
- Array для хранения упорядоченных коллекций данных,
- Date для хранения информации о дате и времени,
- Error для хранения информации об ошибке.

Объект может быть создан с помощью фигурных скобок {…} с необязательным списком свойств.Свойство – это пара «ключ: значение», где ключ – это строка (также называемая «именем свойства»), а значение может быть чем угодно.
```js
let user = new Object(); // синтаксис "конструктор объекта"
const user = {
  age: 1, //Это называется «висячая запятая». 
  "likes birds": true  // имя свойства из нескольких слов должно быть в кавычках
};  // синтаксис "литерал объекта"

user.isAdmin = true;
delete user.age;

// присваивание значения свойству
user["likes birds"] = true;

let key = "likes birds";
// то же самое, что и user["likes birds"] = true;
user[key] = true;

```
Обычно используют вариант с фигурными скобками {...}. Такое объявление называют литералом объекта или литеральной нотацией.
Значение может быть любого типа. Давайте добавим свойство с логическим значением.
Объект, объявленный через const, может быть изменён.
Мы можем использовать квадратные скобки в литеральной нотации для создания вычисляемого свойства.
Свойства могут быть ключи зарезервированные слова.
Если использовать число 0 в качестве ключа, то оно превратится в строку "0":
```js
// эти имена свойств допустимы
let obj = {
  for: 1,
  let: 2,
  return: 3
};

let obj = {
  0: "Тест" // то же самое что и "0": "Тест"
};
```
Есть небольшой подводный камень, связанный со специальным свойством __proto__. Мы не можем установить его в необъектное значение:
let obj = {};
obj.__proto__ = 5; // присвоим число
alert(obj.__proto__); // [object Object], значение - это объект, т.е. не то, что мы ожидали.

* При обращении к свойству, которого нет, возвращается undefined.
Также существует специальный оператор "in" для проверки существования свойства в объекте.
* Обратите внимание, что слева от оператора in должно быть имя свойства. Обычно это строка в кавычках.
Это когда свойство существует, но содержит значение undefined
```js
let user = {};
alert( user.noSuchProperty === undefined ); // true означает "свойства нет"

let obj = {
  test: undefined
};

alert( obj.test ); //  выведет undefined, значит свойство не существует?
alert( "test" in obj ); // true, свойство существует!
```
*Для перебора всех свойств объекта используется цикл for..in. Этот цикл отличается от изученного ранее цикла for(;;).
```js
let user = {
  name: "John",
  age: 30,
  isAdmin: true
};

for (let key in user) {
  // ключи
  alert( key );  // name, age, isAdmin
  // значения ключей
  alert( user[key] ); // John, 30, true
}
```
*Упорядоченность свойств. Свойства упорядочены особым образом: свойства с целочисленными ключами сортируются по возрастанию, остальные располагаются в порядке создания.
Термин «целочисленное свойство» означает строку, которая может быть преобразована в целое число и обратно без изменений.
```js
// Math.trunc - встроенная функция, которая удаляет десятичную часть
alert( String(Math.trunc(Number("49"))) ); // "49", то же самое ⇒ свойство целочисленное
alert( String(Math.trunc(Number("+49"))) ); // "49", не то же самое, что "+49" ⇒ свойство не целочисленное
alert( String(Math.trunc(Number("1.2"))) ); // "1", не то же самое, что "1.2" ⇒ свойство не целочисленное
```
Объекты – это ассоциативные массивы с рядом дополнительных возможностей.\
Они хранят свойства (пары ключ-значение), где:
- Ключи свойств должны быть строками или символами (обычно строками).
- Значения могут быть любого типа.
  
Чтобы получить доступ к свойству, мы можем использовать:
- Запись через точку: obj.property.
- Квадратные скобки obj["property"]. Квадратные скобки позволяют взять ключ из переменной, например, obj[varWithKey].

Дополнительные операторы:
- Удаление свойства: delete obj.prop.
- Проверка существования свойства: "key" in obj.
- Перебор свойств объекта: цикл for for (let key in obj).

То, что мы изучали в этой главе, называется «простым объектом» («plain object») или просто Object.

В JavaScript есть много других типов объектов:
- Array для хранения упорядоченных коллекций данных,
- Date для хранения информации о дате и времени,
- Error для хранения информации об ошибке.
  
# Копирование объектов

Одно из фундаментальных отличий объектов от примитивов заключается в том, что объекты хранятся и копируются «по ссылке», тогда как примитивные значения: строки, числа, логические значения и т.д. – всегда копируются «как целое значение».
```js
// В результате мы имеем две независимые переменные,
let message = "Привет!";
let phrase = message;
```
Переменная, которой присвоен объект, хранит не сам объект, а его «адрес в памяти» – другими словами, «ссылку» на него.
При копировании переменной объекта копируется ссылка, но сам объект не дублируется.
```js
let user = { name: 'John' };
let admin = user;
admin.name = 'Pete'; // изменено по ссылке из переменной "admin"
alert(user.name); // 'Pete'

let a = {};
let b = a; // копирование по ссылке
alert( a == b ); // true, обе переменные ссылаются на один и тот же объект
alert( a === b ); // true
```
Для сравнений типа obj1 > obj2 или для сравнения с примитивом obj == 5 объекты преобразуются в примитивы.\
Синтаксис для копирования объекта: Object.assign(dest, [src1, src2, src3...]).\ - Где dest целевой объект
- Остальные аргументы src1, ..., srcN (может быть столько, сколько необходимо) являются исходными объектами
- Метод копирует свойства всех исходных объектов src1, ..., srcN в целевой объект dest. 
- Также существуют и другие методы клонирования объекта. Например, с использованием оператора расширения clone = {...user}
```js
let user = { name: "John" };
let permissions1 = { canView: true };
let permissions2 = { canEdit: true };
// копируем все свойства из permissions1 и permissions2 в user
Object.assign(user, permissions1, permissions2);
// теперь user = { name: "John", canView: true, canEdit: true }

let user = {
  name: "John",
  age: 30
};
let clone = {}; // новый пустой объект
// давайте скопируем все свойства user в него
for (let key in user) {
  clone[key] = user[key];
}
```
# Вложенное клонирование
До сих пор мы предполагали, что все свойства user примитивныe. Но свойства могут быть и ссылками на другие объекты. Что с ними делать? Теперь недостаточно просто скопировать clone.sizes = user.sizes, потому что user.sizes – это объект, он будет скопирован по ссылке.
```js
let user = {
  name: "John",
  sizes: {
    height: 182,
    width: 50
  }
};
alert( user.sizes.height ); // 182

let clone = Object.assign({}, user);

alert( user.sizes === clone.sizes ); // true, тот же объект

// user и clone обладают общим свойством sizes
user.sizes.width++;       // изменяем свойства в первом объекте
alert(clone.sizes.width); // 51, видим результат в другом

// глубокое клонирование
let user5 = structuredClone(user1);
```
Чтобы исправить это, мы должны использовать цикл клонирования, который проверяет каждое значение user[key] и, если это объект, тогда также копирует его структуру. Это называется «глубоким клонированием». \
Мы можем реализовать глубокое клонирование, используя рекурсию.Или, чтобы не изобретать велосипед заново, возьмите готовую реализацию, например _.cloneDeep(obj) из библиотеки JavaScript lodash.\
Также мы можем использовать глобальный метод structuredClone(), который позволяет сделать полную копию объекта. К сожалению он поддерживается только современными браузерами.\
Объекты, объявленные как константа, могут быть изменены \

# Сборка мусора

Основной концепцией управления памятью в JavaScript является принцип достижимости.\
Если упростить, то «достижимые» значения – это те, которые доступны или используются. \
Вдвижке JavaScript есть фоновый процесс, который называется сборщиком мусора. Он отслеживает все объекты и удаляет те, которые стали недоступными.
```js
// в user находится ссылка на объект
let user = {
  name: "John"
};
user = null; // удаляется объект
```
(*)Недостижимый "остров". Вполне возможна ситуация, при которой целый «остров» взаимосвязанных объектов может стать недостижимым и удалиться из памяти.
Бывший объект family был отсоединён от корня, на него больше нет ссылки, поэтому весь «остров» становится недостижимым и будет удалён.\
*Основной алгоритм сборки мусора называется «алгоритм пометок» (от англ. «mark-and-sweep») со следующими шагами:
- Сборщик мусора «помечает» (запоминает) все корневые объекты.
- Затем он идёт по ним и «помечает» все ссылки из них.
- Затем он идёт по отмеченным объектам и отмечает их ссылки. Все посещённые объекты запоминаются, чтобы в будущем не посещать один и тот же объект дважды.
- …И так далее, пока не будут посещены все достижимые (из корней) ссылки.
- Все непомеченные объекты удаляются.

```js
```


```js
```

```js
```


```js
```

```js
```