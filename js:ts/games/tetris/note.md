Решение — представить игровое поле в виде двумерного массива нулей и единиц. Ноль означает, что клетка свободна, а единица — что занята какой-то частью фигуры. \
Хранить и обрабатывать двумерный массив довольно просто, поэтому решение кажется логичным.
Сами фигуры тоже представим в виде [двумерного массива из нолей и единиц](./imgs/array1.png), но особым образом — в виде квадрата, где единицы отвечают за части фигуры, \
а ноли — за пустое место:
Если вместо квадрата просто взять фактические размеры фигуры и загнать их в массив, то при вращении они не влезут в исходный массив. \
А внутри квадрата их можно вращать как угодно — размер массива от этого не изменится
### Step 1
* делаем массив для игрового поля и заполняем его;
* делаем массивы, которые хранят наши фигуры и их цвета;
* в отдельном массиве будем хранить новые фигуры, которые появятся следующими;
* делаем флаг остановки игры. Пока он не сработает — можно играть.

### Step 2 Генерируем выпадающие фигуры
Первое, что нам понадобится для этого, — функция, которая выдаёт случайное число в заданном диапазоне. По этому числу мы будем выбирать фигуры.
Теперь мы можем создать последовательность из выпадающих фигур. Логика будет такая:
* Задаём обычную последовательность доступных фигур.
* Случайным образом забираем оттуда фигуру и помещаем в игровую последовательность.
* Так делаем до тех пор, пока от обычной последовательности ничего не останется.
* У нас получилась случайная игровая последовательность фигур, с которыми мы будем работать дальше.

Если проверка не прошла, то мы не делаем последнее движение, и фигура просто продолжает падать вниз. Если ей некуда падать и она упёрлась в другие, то нам нужно зафиксировать это в игровом поле. Это значит, что мы записываем в массив, который отвечает за поле, нашу матрицу фигуры, пропуская ноли и записывая только единицы.

Как только фигура встала, нам нужно проверить, получился целый ряд или нет. Если получился — сдвигаем на один ряд вниз всё, что сверху. Такую проверку делаем каждый раз при установке фигуры и начинаем с нижнего ряда, поднимаясь наверх.

### Step 3 Обрабатываем нажатия на клавиши
Всё как в обычном тетрисе: стрелки влево и вправо двигают фигуру, стрелка вверх поворачивает её на 90 градусов, а стрелка вниз ускоряет падение.
Единственное, о чём нужно не забыть — после каждого нажатия вызвать проверку, можно ли так двигать фигуру или нет.

### Step 4 Запускаем движения и анимацию
Смысл главного цикла игры такой:
* на каждом кадре мы очищаем игровое поле и отрисовываем его заново с учётом упавших фигур;
* рисуем текущую фигуру в том месте, где она находится в данный момент.

Так как кадры меняются быстро, мы не заметим постоянного очищения и отрисовки. Нам будет казаться, что фигура просто движется вниз и реагирует на наши действия.